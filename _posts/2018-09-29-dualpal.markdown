---
layout: default
title:  Dual Palindromes
date:   2018-09-29 4:00:00 +0000
categories: USACO
short: dualpal
chapter: 1
section: 3
description: "Write a program that reads two numbers and then finds and prints the first N numbers strictly greater than S that are palindromic when written in two or more number bases."
---
A number that reads the same from right to left as when read from left to right is called a palindrome. The number 12321 is a palindrome; the number 77778 is not. Of course, palindromes have neither leading nor trailing zeroes, so 0220 is not a palindrome.

The number 21 (base 10) is not palindrome in base 10, but the number 21 (base 10) is, in fact, a palindrome in base 2 (10101).

Write a program that reads two numbers (expressed in base 10):

* N (1 <= N <= 15)
* S (0 < S < 10000)

and then finds and prints (in base 10) the first N numbers strictly greater than S that are palindromic when written in two or more number bases (2 <= base <= 10).
Solutions to this problem do not require manipulating integers larger than the standard 32 bits.

## PROGRAM NAME: dualpal

## INPUT FORMAT
A single line with space separated integers N and S.

## SAMPLE INPUT (file dualpal.in)
```none
3 25
```

## OUTPUT FORMAT
N lines, each with a base 10 number that is palindromic when expressed in at least two of the bases 2..10. The numbers should be listed in order from smallest to largest.

## SAMPLE OUTPUT (file dualpal.out)
```none
26
27
28
```

{% contentfor analysis %}

<details>
<summary>
Russ Cox
</summary>

Dual palindromes are actually very common, a fact we can test by writing a program such as this one.

Since they are very common, we can just use a brute force search to test all numbers bigger than s until we find enough dual palindromes.

How do we know they are common enough? Write the brute force program (which is very simple and thus not much effort) and check.

This reasoning is a little circular, but if we had been wrong and ended up needing a more clever and more efficient algorithm, we would have this brute force version to test against.

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <assert.h>

/* is string s a palindrome? */
int
ispal(char *s)
{
    char *t;

    t = s+strlen(s)-1;
    for(t=s+strlen(s)-1; s<t; s++, t--)
	if(*s != *t)
	    return 0;

    return 1;
}

/* put the base b representation of n into s: 0 is represented by "" */
char*
numbconv(char *s, int n, int b)
{
    int len;

    if(n == 0) {
	strcpy(s, "");
	return s;
    }

    /* figure out first n-1 digits */
    numbconv(s, n/b, b);

    /* add last digit */
    len = strlen(s);
    s[len] = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"[n%b];
    s[len+1] = '\0';
    return s;
}

/* is number n a dual palindrome? */
int
isdualpal(int n)
{
    int i, j, npal;
    char s[40];

    npal = 0;
    for(i=2; i<=10; i++)
	if(ispal(numbconv(s, n, i)))
	    npal++;

    return npal >= 2;
}

void
main(void)
{
    FILE *fin, *fout;
    int n, s;

    fin = fopen("dualpal.in", "r");
    fout = fopen("dualpal.out", "w");
    assert(fin != NULL && fout != NULL);

    fscanf(fin, "%d %d", &n, &s);

    for(s++; n>0; s++) {
	if(isdualpal(s)) {
	    fprintf(fout, "%d\n", s);
	    n--;
	}
    }

    exit(0);
}
```

</details>

{% endcontentfor %}