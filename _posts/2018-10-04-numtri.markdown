---
layout: default
title:  Number Triangles
date:   2018-10-04 0:00:00 +0000
categories: USACO
short: numtri
chapter: 1
section: 6
description: "Write a program that calculates the highest sum of numbers that can be passed on a route that starts at the top and ends somewhere on the base of a number triangle. Each step can go either diagonally down to the left or diagonally down to the right."
---

Consider the number triangle shown below. Write a program that calculates the highest sum of numbers that can be passed on a route that starts at the top and ends somewhere on the base. Each step can go either diagonally down to the left or diagonally down to the right.

```none
        7

      3   8

    8   1   0

  2   7   4   4

4   5   2   6   5
```

In the sample above, the route from 7 to 3 to 8 to 7 to 5 produces the highest sum: 30.

### PROGRAM NAME: numtri

### INPUT FORMAT

The first line contains R (1 <= R <= 1000), the number of rows. Each subsequent line contains the integers for that particular row of the triangle. All the supplied integers are non-negative and no larger than 100.

### SAMPLE INPUT (file numtri.in)

```none
5
7
3 8
8 1 0
2 7 4 4
4 5 2 6 5
```

### OUTPUT FORMAT

A single line containing the largest sum using the traversal specified.

### SAMPLE OUTPUT (file numtri.out)

```none
30
```

{% contentfor analysis %}

<details>
<summary>
Russ Cox
</summary>

We keep track (in the "best" array) of total for the best path ending in a given column of the triangle. Viewing the input, a path through the triangle always goes down or down and to the right. To process a new row, the best path total ending at a given column is the maximum of the best path total ending at that column or the one to its left, plus the number in the new row at that column. We keep only the best totals for the current row (in "best") and the previous row (in "oldbest").

```cpp
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <assert.h>

#define MAXR 1000

int
max(int a, int b)
{
	return a > b ? a : b;
}

void
main(void)
{
	int best[MAXR], oldbest[MAXR];
	int i, j, r, n, m;
	FILE *fin, *fout;

	fin = fopen("numtri.in", "r");
	assert(fin != NULL);
	fout = fopen("numtri.out", "w");
	assert(fout != NULL);

	fscanf(fin, "%d", &r);

	for(i=0; i<MAXR; i++)
		best[i] = 0;

	for(i=1; i<=r; i++) {
		memmove(oldbest, best, sizeof oldbest);
		for(j=0; j<i; j++) {
			fscanf(fin, "%d", &n);
			if(j == 0)
				best[j] = oldbest[j] + n;
			else
				best[j] = max(oldbest[j], oldbest[j-1]) + n;
		}
	}

	m = 0;
	for(i=0; i<r; i++)
		if(best[i] > m)
			m = best[i];

	fprintf(fout, "%d\n", m);
	exit(0);
}
```

</details>

<details>
<summary>
Pablo Diaz
</summary>

Or you can always solve from the bottom up, albeit at a cost of memory as Pablo Diaz's solution demonstrates:

```cpp
#include <stdio.h>

int tri[1000][1000];
int res[1000];

int max(int a, int b) { return a > b ? a : b; }

main () {
  FILE *fin  = fopen ("numtri.in", "r");
  FILE *fout = fopen ("numtri.out", "w");
  int i, j, rows;

  // Store the input triangle 
  fscanf (fin, "%d", &rows);
  for (i = 0; i < rows; i++)
    for (j = 0; j <= i; j++)
      fscanf(fin,"%d",&tri[i][j]);

  // Copy the values from the last row
  for (i = 0; i < rows; i++)
    res[i] = tri[rows-1][i];

  // Traverse triangle from the bottom upwards,
  // storing the max paths between 'leaves'
  // and the current item.
  for (i = rows-1; i > 0; i--)
    for (j = 0; j <= i; j++)
      res[j] = tri[i-1][j] + max(res[j],res[j+1]);

  fprintf(fout,"%d\n",res[0]);

  exit (0);
}
```

</details>

{% endcontentfor %}